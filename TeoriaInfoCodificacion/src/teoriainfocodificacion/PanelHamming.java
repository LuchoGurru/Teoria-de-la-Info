package teoriainfocodificacion;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.Random;
import javax.swing.JOptionPane;

/**
 *
 * @author Lucho
 */
public class PanelHamming extends javax.swing.JFrame {
    private static String archivoElegido;
    private String archivoIzq;
    private String archivoDer;
    private int totalBitsAleer,bloqueHamming; // inicializo en Proteger archivo
    
    private boolean [] aGuardar;
    

    public PanelHamming() {
        initComponents();
        this.jEditorPaneDer.setContentType("text/html");
        this.jEditorPaneIzq.setContentType("text/html");
        elegirArchivo("archivo.txt");//faltaria un metodo porque se tiene que activar de un boton en teoria, sino lo dejamos asi
        archivoDer="";
        archivoIzq="";
    }
    
    public static void main(String[] args) {
       java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
               // Nodo.crearListaDeFrecuencia(new File("./archivo.txt"));
                new PanelHamming().setVisible(true);  
              //  Nodo.leerHuffman("tablaHuff.txt", "");
            }
        });
    }
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jButton3 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jComboHamming = new javax.swing.JComboBox<>();
        jButton1 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jLabel5 = new javax.swing.JLabel();
        jLabelArchHA = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabelArchHE = new javax.swing.JLabel();
        jComboArchivosADecodificar = new javax.swing.JComboBox<>();
        jLabel3 = new javax.swing.JLabel();
        jPanelIzq = new javax.swing.JPanel();
        jLabelTituloIzq = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        jEditorPaneIzq = new javax.swing.JEditorPane();
        jPanelDer = new javax.swing.JPanel();
        jLabelTituloDer = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jEditorPaneDer = new javax.swing.JEditorPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2), "Codificacion Hamming de Archivos txt.", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Segoe UI Historic", 1, 14))); // NOI18N

        jButton3.setText("Dañar Archivo");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jLabel1.setText(" Elegir el tamaño de los bloques Hamming:");

        jComboHamming.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "32-BITS (.HA1)", "128-BITS (.HA2)", "1024-BITS (.HA3)", "4096-BITS (.HA4)", "16384-BITS (.HA5)" }));

        jButton1.setText("Proteger Archivo");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton5.setText("Decodificar Archivo");
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jLabel5.setText("ArchivoProtegido:");

        jLabelArchHA.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelArchHA.setText("Nombre Archivo Elegido.HAx");

        jLabel7.setText("ArchivoDañado:");

        jLabelArchHE.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelArchHE.setText("Nombre Archivo Elegido.HEx");

        jLabel3.setText(" Elegir el Archivo a desprotejer:");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jComboHamming, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButton5, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jComboArchivosADecodificar, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabelArchHA, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel5)
                            .addComponent(jLabel7))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(jLabelArchHE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jComboHamming, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabelArchHA, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel7, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabelArchHE, javax.swing.GroupLayout.PREFERRED_SIZE, 24, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 12, Short.MAX_VALUE)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jComboArchivosADecodificar, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jButton5, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(26, 26, 26))
        );

        jPanelIzq.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));
        jPanelIzq.setMinimumSize(new java.awt.Dimension(372, 531));
        jPanelIzq.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabelTituloIzq.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelTituloIzq.setText("Nombre Archivo Elegido.txt");
        jPanelIzq.add(jLabelTituloIzq, new org.netbeans.lib.awtextra.AbsoluteConstraints(12, 15, -1, 23));

        jEditorPaneIzq.setEditable(false);
        jEditorPaneIzq.setMaximumSize(new java.awt.Dimension(368, 476));
        jEditorPaneIzq.setMinimumSize(new java.awt.Dimension(368, 476));
        jEditorPaneIzq.setPreferredSize(new java.awt.Dimension(368, 476));
        jScrollPane3.setViewportView(jEditorPaneIzq);

        jPanelIzq.add(jScrollPane3, new org.netbeans.lib.awtextra.AbsoluteConstraints(12, 44, 348, 476));

        jPanelDer.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));
        jPanelDer.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        jLabelTituloDer.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelTituloDer.setText("Nombre Archivo Elegido.txt");
        jPanelDer.add(jLabelTituloDer, new org.netbeans.lib.awtextra.AbsoluteConstraints(12, 13, -1, 23));

        jEditorPaneDer.setEditable(false);
        jEditorPaneDer.setMaximumSize(new java.awt.Dimension(368, 476));
        jEditorPaneDer.setMinimumSize(new java.awt.Dimension(368, 476));
        jEditorPaneDer.setPreferredSize(new java.awt.Dimension(368, 476));
        jScrollPane1.setViewportView(jEditorPaneDer);

        jPanelDer.add(jScrollPane1, new org.netbeans.lib.awtextra.AbsoluteConstraints(12, 42, 366, 475));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelIzq, javax.swing.GroupLayout.PREFERRED_SIZE, 370, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jPanelDer, javax.swing.GroupLayout.DEFAULT_SIZE, 387, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanelDer, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanelIzq, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 530, javax.swing.GroupLayout.PREFERRED_SIZE)))
            .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:

        bloqueHamming=0;
        String ext="";
        switch(jComboHamming.getSelectedIndex()){//Seleccionado en Panel
            case 0:{
                ext=".HE1";
                bloqueHamming=32;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 1:{
                ext=".HE2";
                bloqueHamming=128;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 2:{
                ext=".HE3";
                bloqueHamming=1024;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 3:{
                ext=".HE4";
                bloqueHamming=4096;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 4:{
                ext=".HE5";
                bloqueHamming=16384;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
        }
        String nombreArchivo = jComboArchivosADecodificar.getItemAt(jComboArchivosADecodificar.getSelectedIndex());
        romperArchivo(nombreArchivo, bloqueHamming, ext);
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        jComboArchivosADecodificar.removeAllItems();
        protegerArchivo();
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton5ActionPerformed
        String nombreArchivo = jComboArchivosADecodificar.getItemAt(jComboArchivosADecodificar.getSelectedIndex());
        String ext = nombreArchivo.substring(nombreArchivo.length()-3);//Extencion
        if(ext.contains("HE")){//Si el archivo esta dañado
            ext = nombreArchivo.substring(nombreArchivo.length()-1);//Tomo el ultimo
            if(0==JOptionPane.showConfirmDialog(null, "¿Desea Arreglar el archivo?","",JOptionPane.YES_NO_OPTION)){
                System.out.println("corregir");
                //Aca tengo que armar la extencion DHx
                ext =".DH"+ext;
                decodificarArchivo(nombreArchivo, ext,true);
                //Corregido “.DHx”
            }else{  
                //Aca tengo que armar la extencion DEx
                ext =".DE"+ext;
                decodificarArchivo(nombreArchivo, ext,false);
                //No corregido “.DEx”
            } 
        }else{
            ext = nombreArchivo.substring(nombreArchivo.length()-1);
            //inicializado en el boton  "protegerArchivo()"
            //Aca tengo que armar la extencion DHx
            ext =".DH"+ext;
            decodificarArchivo(nombreArchivo, ext,false);
        }
    }//GEN-LAST:event_jButton5ActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton5;
    private javax.swing.JComboBox<String> jComboArchivosADecodificar;
    private javax.swing.JComboBox<String> jComboHamming;
    private javax.swing.JEditorPane jEditorPaneDer;
    private javax.swing.JEditorPane jEditorPaneIzq;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabelArchHA;
    private javax.swing.JLabel jLabelArchHE;
    private javax.swing.JLabel jLabelTituloDer;
    private javax.swing.JLabel jLabelTituloIzq;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanelDer;
    private javax.swing.JPanel jPanelIzq;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    // End of variables declaration//GEN-END:variables
    public void elegirArchivo(String urlArch){
        archivoElegido=urlArch;
        //archivoIzq=urlArch;
    }
    
    public void protegerArchivo(){  
        bloqueHamming=0;
        String ext="";
        switch(jComboHamming.getSelectedIndex()){//Seleccionado en Panel
            case 0:{
                ext=".HA1";
                bloqueHamming=32;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 1:{
                ext=".HA2";
                bloqueHamming=128;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 2:{
                ext=".HA3";
                bloqueHamming=1024;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 3:{
                ext=".HA4";
                bloqueHamming=4096;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
            case 4:{
                ext=".HA5";
                bloqueHamming=16384;
                totalBitsAleer= cantBitsInfo(bloqueHamming);
                break;
            }
        }
        readFileToBynari(totalBitsAleer,ext);
    }
    
    public void decodificarArchivo(String nameArchivo,String ext,boolean arreglar){ 
        //El totalBitsaleer y el bloqueHamming los tenemos globales e inicializados en la funcion de arriba "protegerArchivo()"
        //Te paso la extencion para ponerle al archivo que vas a crear
        
        //↓Ver javadoc↓ ahi explico los parametros
        readFileToText(nameArchivo,totalBitsAleer, bloqueHamming,ext,arreglar);
    }
    
    public int cantBitsInfo(int ham){
        int bitsRed = (int) (Math.log(ham)/ Math.log(2)); // creo que lo de floor ni hace falta
        return ham-bitsRed-1;
    }
    
    public String arrToString(byte[] b){
        int i=0;
        String strArray="";
        for(i=0; i< b.length;i++){
            strArray+=String.format("%8s", Integer.toBinaryString(b[i])).replace(' ', '0');
        }
        return strArray;
    }
    
    public String arrBytesToHammingString2(byte[] bytesLinea, int totalBI){
        String lineaDeBits="";
        int hasta=totalBI-1; //EJ: 26
        int desde = 0;
        boolean primera = true;
        while(hasta<bytesLinea.length){
            boolean bitsInfo[] = getIntervaloBits(bytesLinea, desde, hasta);
            bitsInfo = Hamming.getHamming(bitsInfo);
            if(primera){
                aGuardar = bitsInfo;
            }
            else{
                unirArreglos(bitsInfo); //Appendeo el arreglo hamminizado al arreglo que voy a guardar en archivo
            }
            hasta += totalBI-1;
            desde += hasta+1;
            
            lineaDeBits += Hamming.toString(bitsInfo)+"\n";  //le meto el bloque hamminizado
        }
        if(desde < bytesLinea.length){
            boolean bitsInfo[] = getIntervaloBits(bytesLinea, desde, hasta);
            bitsInfo = Hamming.getHamming(bitsInfo);
            unirArreglos(bitsInfo);
            lineaDeBits += Hamming.toString(bitsInfo);
        }
        return lineaDeBits;
    }
    
    public String arrBytesToHammingString(byte[] bytesLinea, int totalBI){
        String lineaDeBits=""; 
        String strBits = arrToString(bytesLinea); //String de bits
        int hasta=totalBI; //EJ: 26
        while(hasta<strBits.length()){
            String bitsInfo = strBits.substring(0, hasta);
            lineaDeBits += Hamming.toString(Hamming.getHamming(bitsInfo));  //le meto el bloque hamminizado
            strBits = strBits.substring(hasta); // le como "hasta bits" a la linea
        }
        if(strBits.length()>0){
            //completo los ceros y lo hamminizo 
            int cantCeros= totalBI - strBits.length();
            int j=0;
            for(j=0; j<cantCeros;j++){
                strBits+="0";
            }
            lineaDeBits += Hamming.toString(Hamming.getHamming(strBits));
        }
        return lineaDeBits;
    }
    
    public void romperArchivo(String pathAleer, int bitsBloque,String ext){
        boolean primero=true;
        File archivo = null;
        FileReader fr = null;
        BufferedReader br = null;
        try {
            archivo = new File("./"+pathAleer);                                   // Apertura del fichero
            fr = new FileReader(archivo);                                       // creacion de BufferedReader para poder hacer el metodo readLine()).
            br = new BufferedReader(fr);                                        // Lectura del fichero
            String sinExtencion=pathAleer.substring(0, pathAleer.length()-4);//Saco la extencion
            File archivo2 = new File("./"+sinExtencion+ext);//.H
            BufferedWriter bw;
            if(archivo2.exists()){
                bw = new BufferedWriter(new FileWriter(archivo2));
            }
            else{
                archivo2.createNewFile();
                bw = new BufferedWriter(new FileWriter(archivo2));
            }
            String linea;
            String aEscribirBytes;
            String aux;
            String auxColor;
            String textoIzq="";
            String textoDer="";
            String auxRoto;
            String textoDerAux = "";
            String htmlAux="";
            
            boolean [] arr;
            int hasta = bitsBloque;
            int posRota;
            while ((linea = br.readLine()) != null) {
                aux="";
                htmlAux = linea.replace("<", "&lt;");
                htmlAux = htmlAux.replace(">", "&gt;");
                textoIzq += htmlAux +"<br>";
                textoDerAux = "";
                
                while(hasta<=linea.length()){//Si bloque <  final del String
                    aEscribirBytes = linea.substring(0, hasta);
                    linea = linea.substring(hasta);
                    arr= Hamming.toArray(aEscribirBytes);
                    posRota = this.romper((float) 0.5, arr);
                    auxRoto = Hamming.toString(arr);
                    
                    if(posRota>=0){
                        auxColor = auxRoto.substring(0, posRota)+"<font color=\"red\"><b>"+auxRoto.charAt(posRota)+"</b></font>"+auxRoto.substring(posRota+1);
                        textoDerAux += auxColor;
                    }
                    else{
                        textoDerAux += auxRoto;
                    }
                    
                    aux += auxRoto;
                }
                
                textoDer += textoDerAux +"<br>";
                if(primero){
                    primero=false;
                    bw.write(aux);
                }else{
                    bw.write('\n'+aux);
                }                
            }
            bw.close();
            jComboArchivosADecodificar.addItem(archivo2.getPath().substring(2));//Añado archivo a decodificar al combo box
            mostrarArchivos(archivo.getPath(), archivo2.getPath(), textoIzq, textoDer);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // En el finally cerramos el fichero, para asegurarnos
            // que se cierra tanto si todo va bien como si salta 
            // una excepcion.
            try {
                if (null != fr) {
                    fr.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }
    
    /**
     * Recibe la cantidad de BITS de informacion necesaria para cada bloque Hamming.
     * @param cantBits 
     */
    public void readFileToBynari(int cantBits,String extArchivo){
       boolean primero=true;
        File archivo = null;
        FileReader fr = null;
        BufferedReader br = null;
        int i = 0; // indice que va a tomar la cantidad de bits de info necesaria por iteracion
        try {
            archivo = new File("./"+archivoElegido); //.txt
            fr = new FileReader(archivo); 
            br = new BufferedReader(fr);
            String sinExtencion=archivoElegido.substring(0, archivoElegido.length()-4);//Saco la extencion
            File archivo2 = new File("./"+sinExtencion+extArchivo);//.HAx
            BufferedWriter bw;
            if(archivo2.exists()){
                bw = new BufferedWriter(new FileWriter(archivo2));
            }
            else{
                archivo2.createNewFile();
                bw = new BufferedWriter(new FileWriter(archivo2));
            }
            String linea;
            String textoIzq = "";
            String textoDer = "";
            String htmlAux = "";
            while ((linea = br.readLine()) != null) {//linea por linea
                htmlAux = linea.replace("<", "&lt;");
                htmlAux = htmlAux.replace(">", "&gt;");
                textoIzq += htmlAux +"<br>";
                String aEscribir= arrBytesToHammingString(linea.getBytes(), cantBits);
                htmlAux = aEscribir.replace("<", "&lt;");
                htmlAux = htmlAux.replace(">", "&gt;");
                textoDer += htmlAux + "<br>";
                if(primero){
                    primero=false;
                    bw.write(aEscribir);
                }else{
                    bw.write('\n'+aEscribir);
                } 
            }
            bw.close(); 
            jComboArchivosADecodificar.addItem(archivo2.getPath().substring(2));//Añado archivo a decodificar
            mostrarArchivos(archivo.getPath(), archivo2.getPath(), textoIzq, textoDer); 
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // En el finally cerramos el fichero, para asegurarnos
            // que se cierra tanto si todo va bien como si salta 
            // una excepcion.
            try {
                if (null != fr) {
                    fr.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }
    
    public String decodificar(String textCode,int tamBloque,int cantBitInfo,boolean arreglar){ 
            String aEscribir="";
            String auxString="";
            String retorno="";
            int hasta = tamBloque;
            byte byteAux;
            while(hasta<=textCode.length()){//Si bloque <  final del String
                aEscribir = textCode.substring(0, hasta);
                textCode = textCode.substring(hasta);
                System.out.println(aEscribir.length()+"Este es el tamaño del bloque");
                boolean[] arr= Hamming.toArray(aEscribir);
              //  arr = Hamming.getInfo(arr, arr.length-cantBitInfo); Asi estaba antes
                arr = Hamming.getInfo(arr,arreglar);
                System.out.println(arr.length+"Este es el tamaño de la info");
                auxString += Hamming.toString(arr);
            }
            while(8<auxString.length()){
                aEscribir = auxString.substring(0, 8);
                auxString = auxString.substring(8);
                try{
                    byteAux = Byte.parseByte(aEscribir, 2);
                }
                catch(NumberFormatException e){
                    byteAux = '\0';
                }
                if(byteAux == 0)
                    continue;
                retorno +=(char)byteAux;
            }
        return retorno;
    }
    /**
     * 
     * @param pathAleer nombre del archivo a Decodificar
     * @param bitsAleer Bits de Informacion
     * @param bitsBloque Bits Info + Bits control
     * @param ext la extencion que le tenes que poner al archivo creado
     */
    public void readFileToText(String pathAleer,int bitsAleer, int bitsBloque,String ext,boolean arreglar){ 
       boolean primero=true;
        File archivo = null;
        FileReader fr = null;
        BufferedReader br = null;
        try {
            archivo = new File("./"+pathAleer);                                 // Apertura del fichero
            fr = new FileReader(archivo);                                       // creacion de BufferedReader para poder hacer el metodo readLine()).
            br = new BufferedReader(fr);                                        // Lectura del fichero
            String sinExtencion=pathAleer.substring(0, pathAleer.length()-4);   //Saco la extencion
            File archivo2 = new File("./"+sinExtencion+ext);//.H
            BufferedWriter bw;
            if(archivo2.exists()){
                bw = new BufferedWriter(new FileWriter(archivo2));
            }
            else{
                archivo2.createNewFile();
                bw = new BufferedWriter(new FileWriter(archivo2));
            }
            String linea;
            String aEscribirBytes="";
            String textoIzq="";
            String textoDer="";
            String htmlAux="";
            while ((linea = br.readLine()) != null) {
                htmlAux = linea.replace("<", "&lt;");
                htmlAux = htmlAux.replace(">", "&gt;");
                textoIzq += htmlAux+"<br>";
                aEscribirBytes=decodificar(linea, bitsBloque, bitsAleer,arreglar);
                htmlAux = aEscribirBytes.replace("<", "&lt;");
                htmlAux = htmlAux.replace(">", "&gt;");
                textoDer += htmlAux + "<br>";
                if(primero){
                    primero=false;
                    bw.write(aEscribirBytes);
                }else{
                    bw.write('\n'+aEscribirBytes);
                }
            }
            bw.close();
            mostrarArchivos(archivo.getPath(), archivo2.getPath(),textoIzq,textoDer);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            // En el finally cerramos el fichero, para asegurarnos
            // que se cierra tanto si todo va bien como si salta 
            // una excepcion.
            try {
                if (null != fr) {
                    fr.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }
    
    public void settearLabels(String path){ 
        String ext=path.substring(path.length()-4,path.length()-1);
        switch(ext){
            case".HA":{
                jLabelArchHA.setText(path.substring(2)); 
                break;
            }
            case".HE":{ 
                jLabelArchHE.setText(path.substring(2));
                break;
            }
        }
    }
    /**
     * Recibe dos archivos y los imprime, no hay mucha vuelta.
     * @param textoIzq    * @param izq
     * @param der 
     * @param textoDer 
     */
    public void mostrarArchivos(String izq,String der, String textoIzq, String textoDer){  
        archivoIzq=izq; 
        archivoDer=der;//de la forma "./nombre.ext"
        settearLabels(archivoIzq);
        settearLabels(archivoDer);
        jLabelTituloIzq.setText(archivoIzq.substring(2,archivoIzq.length()));
        jLabelTituloDer.setText(archivoDer.substring(2,archivoDer.length()));
        this.jEditorPaneDer.setText(textoDer);
        this.jEditorPaneIzq.setText(textoIzq);
    }
    /**
     * Recibe por parametro una probabilidad la cual es un numero flotante entre 0 y 1
     * un arreglo hamminizado de booleanos
     * Retorna un numero entero el cual es la posicion que rompio
     * Devuelve 0 si no rompio el arreglo
     * @param prob
     * @param hamming
     * @return 
     */
    public int romper(float prob, boolean [] hamming){
        Random random = new Random();
        int posRomper = random.nextInt(hamming.length-1);
        if(Math.random()<=prob){
            hamming[posRomper] = !hamming[posRomper];
            return posRomper;
        }
        return -1;
    }
   
    /**
     * Recibe un byte y una posicion y devulve el valor booleano del bit de esa posicion
     * @param b
     * @param pos
     * @return 
     */
    public static boolean getBitDeByte(byte b, int pos){
        return (1 & (b >> pos))==1;
    }
    
    /**
     * Recibe un arreglo de bytes por parametro, una posicion de un bit inicial y una posicion de un bit final
     * Retorna un arreglo de booleanos que contiene los bits desde la posicion inicial hasta la final
     * @param arr
     * @param inicio
     * @param fin
     * @return 
     */
    public boolean [] getIntervaloBits(byte [] arr,int inicio, int fin){
        int byteI = (int) Math.ceil(inicio/8) - 1; //Byte dnd esta el primer bit
        int byteF = (int) Math.ceil(fin/8) - 1; //Byte dnd esta el ultimo bit
        int bitI = inicio - (byteI)*8; //Primer bit del primer byte
        int bitF = fin - (byteF)*8; //Ultimo bit del ultimo byte
        int t,aux=0;
        boolean retorno[] = new boolean[fin-inicio+1];
        boolean completar=false;
        
        if(byteF >= arr.length){ //Si el intervalo se sale del tamaño del arreglo tengo que completar con 0s
            completar = true;
            byteF = arr.length-1;
        }      
        
        bucle:
        for(int i=byteI; i<= byteF; i++){
            if(i==byteI){ //Si es la primera iteracion debo empezar desde bitI
                t = bitI;
            }
            else{
                t=0;
            }
            while(t<8){
                retorno[aux]=getBitDeByte(arr[i],t); //Esto puede que sea al revez no me acuerdo
                if(byteI==byteF && t==bitF && !completar){ //Si estoy en el ultimo byte y en el ultimo bit y ademas no hay que completar nada rompo el bucle
                    break bucle;
                }
                aux++;//indice del arreglo de booleanos
                t++; //indice del byte actual
            }
        }
        if(completar){
            while(aux<retorno.length){
                retorno[aux]=false; //completo con 0s
                aux++;
            }
        }
        return retorno;
    }
    
    /**
     * Une el arreglo pasado por parametro al arreglo de booleanos que se va a guardar en archivo
     * @param aUnir 
     */
    public void unirArreglos(boolean [] aUnir){
        int tam = aUnir.length + aGuardar.length;
        boolean nuevo[] = new boolean[tam];
        for(int i=0; i<aGuardar.length; i++)
            nuevo[i]=aGuardar[i];
        for(int i = aGuardar.length; i<tam; i++)
            nuevo[i] = aUnir[i-aGuardar.length];
        aGuardar=nuevo;
    }
}
